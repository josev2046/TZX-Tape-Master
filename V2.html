<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JV's TZX Master - V2</title>
    <style>
        body { 
            background: #111; color: #ccc; 
            font-family: 'Courier New', monospace; 
            margin: 0; padding: 0;
            display: flex; height: 100vh; overflow: hidden;
            user-select: none;
        }

        /* SIDEBAR - Photoshop Style */
        .sidebar {
            width: 70px; background: #222; border-right: 2px solid #000;
            display: flex; flex-direction: column; align-items: center;
            padding-top: 15px; gap: 10px; z-index: 100;
        }

        /* RUBBER KEYS */
        .rubber-key {
            width: 50px; height: 44px; background: #3a3a3a;
            border-radius: 4px; border: none; border-bottom: 4px solid #000;
            color: #fff; font-size: 10px; font-weight: bold; cursor: pointer;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: all 0.1s;
        }
        .rubber-key:active, .rubber-key.active {
            transform: translateY(2px); border-bottom: 1px solid #000;
            background: #111; color: #0f0;
        }
        /* Toggle specific state */
        .rubber-key.eye-active { color: #00bcd4; box-shadow: inset 0 0 5px #00bcd4; }

        /* WORKSPACE */
        #workspace {
            flex-grow: 1; position: relative;
            display: flex; flex-direction: column;
            background: #181818; overflow: hidden;
        }

        .top-nav {
            background: #282828; padding: 8px 15px;
            display: flex; gap: 20px; align-items: center;
            border-bottom: 1px solid #000; font-size: 11px;
        }

        #stage-viewport {
            flex-grow: 1; overflow: auto;
            display: flex; justify-content: center; align-items: center;
            background-image: radial-gradient(#333 1px, transparent 1px);
            background-size: 20px 20px;
        }

        #stage {
            position: relative;
            width: 256px; height: 192px;
            background: #fff;
            image-rendering: pixelated;
            box-shadow: 0 0 20px rgba(0,0,0,1);
            transform-origin: center;
        }

        /* RIGHT PANEL */
        .right-panel {
            width: 260px; background: #222; border-left: 2px solid #000;
            display: flex; flex-direction: column; padding: 10px;
        }
        textarea {
            flex-grow: 1; background: #000; color: #0f0;
            border: 1px solid #444; font-family: 'Courier New', monospace;
            padding: 8px; font-size: 11px; resize: none;
        }

        .swatch-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; padding: 5px; background: #000; border-radius: 4px; }
        .swatch { width: 18px; height: 18px; border: 1px solid #333; cursor: pointer; }
        .swatch.active { border: 1px solid #fff; outline: 1px solid #fff; }

        canvas { position: absolute; top: 0; left: 0; }
        #speccyCanvas { z-index: 10; cursor: crosshair; }
        #gridCanvas { z-index: 20; pointer-events: none; }
        #refImg { position: absolute; top: 0; left: 0; pointer-events: none; opacity: 0.5; transform-origin: top left; }
    </style>
</head>
<body>

    <div class="sidebar">
        <button id="btnPencil" class="rubber-key active" onclick="setTool('pencil')">PIX</button>
        <button id="btnBrush" class="rubber-key" onclick="setTool('brush')">COL</button>
        <button id="btnMove" class="rubber-key" onclick="setTool('mover')">MOV</button>
        
        <div class="swatch-grid">
            <div class="swatch" style="background:#000" onclick="setColor(0)"></div>
            <div class="swatch" style="background:#0000D7" onclick="setColor(1)"></div>
            <div class="swatch" style="background:#D70000" onclick="setColor(2)"></div>
            <div class="swatch" style="background:#D700D7" onclick="setColor(3)"></div>
            <div class="swatch" style="background:#00D700" onclick="setColor(4)"></div>
            <div class="swatch" style="background:#00D7D7" onclick="setColor(5)"></div>
            <div class="swatch" style="background:#D7D700" onclick="setColor(6)"></div>
            <div class="swatch" style="background:#FFF" onclick="setColor(7)"></div>
        </div>

        <button id="btnRefToggle" class="rubber-key eye-active" onclick="toggleRef()" style="display:none">üëÅ EYE</button>
        <button class="rubber-key" onclick="undo()">UNDO</button>
        <button class="rubber-key" onclick="toggleGrid()">GRID</button>
        <button class="rubber-key" onclick="clearAll()">CLR</button>
    </div>

    <div id="workspace">
        <div class="top-nav">
            <strong>JV's TZX MASTER</strong>
            <span>Zoom: <button onclick="adjustZoom(-1)">-</button> <b id="zoomLabel">10x</b> <button onclick="adjustZoom(1)">+</button></span>
            <div id="refTools" style="display:none; gap:10px">
                SC:<input id="inpScale" type="number" value="100" style="width:45px" oninput="updateRef('scale', this.value)">
                X:<input id="inpX" type="number" value="0" style="width:40px" oninput="updateRef('x', this.value)">
                Y:<input id="inpY" type="number" value="0" style="width:40px" oninput="updateRef('y', this.value)">
            </div>
        </div>

        <div id="stage-viewport">
            <div id="stage">
                <div id="refContainer"><img id="refImg" src="" alt=""></div>
                <canvas id="attrCanvas" width="256" height="192"></canvas>
                <canvas id="speccyCanvas" width="256" height="192"></canvas>
                <canvas id="gridCanvas" width="2560" height="1920" style="width:256px; height:192px;"></canvas>
            </div>
        </div>
    </div>

    <div class="right-panel">
        <textarea id="codeEditor" placeholder="Paste BASIC POKEs..."></textarea>
        <div style="margin-top:10px; display:flex; flex-direction:column; gap:5px">
            <label for="fileInput" class="rubber-key" style="width:100%; height:30px; line-height:30px; text-align:center">üìÇ IMAGE</label>
            <input type="file" id="fileInput" style="display:none" onchange="loadRef(this)">
            <button onclick="parseBasic()" style="background:#333; color:white; padding:5px; border:1px solid #555; cursor:pointer">üîÑ IMPORT POKES</button>
            <div style="display:grid; grid-template-columns:1fr 1fr; gap:5px">
                <button onclick="downloadBinTap()" style="background:#2e7d32; color:white; border:none; padding:5px; cursor:pointer">üíæ TAP</button>
                <button onclick="downloadTzx()" style="background:#c62828; color:white; border:none; padding:5px; cursor:pointer">üìº TZX</button>
            </div>
        </div>
    </div>

    <script>
        const speccyCanvas = document.getElementById('speccyCanvas');
        const ctx = speccyCanvas.getContext('2d', {willReadFrequently: true});
        const attrCanvas = document.getElementById('attrCanvas');
        const attrCtx = attrCanvas.getContext('2d');
        const gridCanvas = document.getElementById('gridCanvas');
        const gridCtx = gridCanvas.getContext('2d');
        const refImg = document.getElementById('refImg');
        const stage = document.getElementById('stage');
        const zoomLabel = document.getElementById('zoomLabel');
        const inpScale = document.getElementById('inpScale');
        const inpX = document.getElementById('inpX');
        const inpY = document.getElementById('inpY');
        const btnRefToggle = document.getElementById('btnRefToggle');

        let currentScale = 10;
        let activeTool = 'pencil';
        let activeColor = 0;
        let isDrawing = false;
        let isDraggingRef = false;
        let lastDragX = 0, lastDragY = 0;
        let refState = { scale: 1.0, x: 0, y: 0, opacity: 0.5, visible: true };
        let attrData = new Array(768).fill(56);
        let historyStack = [];
        const PALETTE = ['#000000', '#0000D7', '#D70000', '#D700D7', '#00D700', '#00D7D7', '#D7D700', '#FFFFFF'];

        function init() { applyZoom(); drawGrid(); saveState(); }

        // --- CONVERSION ENGINE ---
        function autoConvertImage() {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = 256; tempCanvas.height = 192;
            const tCtx = tempCanvas.getContext('2d');
            tCtx.fillStyle = "white"; tCtx.fillRect(0, 0, 256, 192);
            tCtx.drawImage(refImg, refState.x, refState.y, refImg.naturalWidth * refState.scale, refImg.naturalHeight * refState.scale);
            const pixels = tCtx.getImageData(0, 0, 256, 192).data;
            ctx.clearRect(0, 0, 256, 192);
            for (let by = 0; by < 24; by++) { for (let bx = 0; bx < 32; bx++) { processBlock(bx, by, pixels); } }
            redrawAttributes(); saveState();
        }

        function processBlock(bx, by, pixels) {
            let blockColors = [];
            for (let py = 0; py < 8; py++) {
                for (let px = 0; px < 8; px++) {
                    const idx = (((by * 8 + py) * 256) + (bx * 8 + px)) * 4;
                    const brightness = (pixels[idx] * 0.299 + pixels[idx+1] * 0.587 + pixels[idx+2] * 0.114);
                    if (brightness < 128) { ctx.fillStyle = "black"; ctx.fillRect(bx * 8 + px, by * 8 + py, 1, 1); }
                    blockColors.push(getNearestSpeccyColor(pixels[idx], pixels[idx+1], pixels[idx+2]));
                }
            }
            const counts = {};
            blockColors.forEach(c => counts[c] = (counts[c] || 0) + 1);
            const sorted = Object.keys(counts).sort((a, b) => counts[b] - counts[a]);
            attrData[by * 32 + bx] = (parseInt(sorted[0]) * 8);
        }

        function getNearestSpeccyColor(r, g, b) {
            let minDist = Infinity, bestIndex = 0;
            const specRGB = [[0,0,0], [0,0,215], [215,0,0], [215,0,215], [0,215,0], [0,215,215], [215,215,0], [255,255,255]];
            specRGB.forEach((rgb, i) => {
                const d = Math.sqrt((r-rgb[0])**2 + (g-rgb[1])**2 + (b-rgb[2])**2);
                if (d < minDist) { minDist = d; bestIndex = i; }
            });
            return bestIndex;
        }

        // --- INTERACTION ---
        function getPos(e) {
            const rect = speccyCanvas.getBoundingClientRect();
            return { 
                x: (e.clientX - rect.left) * (256 / rect.width), 
                y: (e.clientY - rect.top) * (192 / rect.height) 
            };
        }

        speccyCanvas.onmousedown = (e) => { 
            const pos = getPos(e);
            if (activeTool === 'mover') { isDraggingRef = true; lastDragX = pos.x; lastDragY = pos.y; } 
            else { isDrawing = true; useTool(e); }
        };

        window.onmouseup = () => { isDraggingRef = false; if (isDrawing) { isDrawing = false; saveState(); } };
        
        speccyCanvas.onmousemove = (e) => {
            const pos = getPos(e);
            if (isDraggingRef) {
                refState.x += (pos.x - lastDragX); refState.y += (pos.y - lastDragY);
                lastDragX = pos.x; lastDragY = pos.y;
                inpX.value = Math.round(refState.x); inpY.value = Math.round(refState.y);
                updateRefVisuals();
            } else if (isDrawing) { useTool(e); }
        };

        function useTool(e) {
            const pos = getPos(e);
            const gx = Math.floor(pos.x), gy = Math.floor(pos.y);
            if (activeTool === 'pencil') {
                ctx.fillStyle = "black"; ctx.fillRect(gx, gy, 1, 1);
            } else if (activeTool === 'brush') {
                const ax = Math.floor(gx / 8), ay = Math.floor(gy / 8);
                if (ax >= 0 && ax < 32 && ay >= 0 && ay < 24) {
                    attrData[ay * 32 + ax] = (activeColor * 8); redrawAttributes();
                }
            }
        }

        function redrawAttributes() {
            attrCtx.clearRect(0, 0, 256, 192);
            for (let i = 0; i < 768; i++) {
                const paper = (attrData[i] >> 3) & 7;
                if (paper !== 7) {
                    attrCtx.fillStyle = PALETTE[paper];
                    attrCtx.fillRect((i % 32) * 8, Math.floor(i / 32) * 8, 8, 8);
                }
            }
        }

        // --- UI CONTROLS ---
        function setTool(t) {
            activeTool = t;
            document.querySelectorAll('.sidebar .rubber-key').forEach(b => b.classList.remove('active'));
            document.getElementById('btn' + t.charAt(0).toUpperCase() + t.slice(1)).classList.add('active');
            speccyCanvas.style.cursor = t === 'mover' ? 'move' : 'crosshair';
        }

        function setColor(c) {
            activeColor = c;
            document.querySelectorAll('.swatch').forEach((s, i) => s.classList.toggle('active', i === c));
            setTool('brush');
        }

        function toggleRef() {
            refState.visible = !refState.visible;
            document.getElementById('refContainer').style.display = refState.visible ? 'block' : 'none';
            btnRefToggle.classList.toggle('eye-active', refState.visible);
        }

        function loadRef(input) {
            if (input.files && input.files[0]) {
                const r = new FileReader();
                r.onload = (e) => { 
                    refImg.src = e.target.result; 
                    refImg.onload = () => {
                        const s = Math.min(256/refImg.naturalWidth, 192/refImg.naturalHeight);
                        refState.scale = s; refState.x = (256-refImg.naturalWidth*s)/2; refState.y = (192-refImg.naturalHeight*s)/2;
                        inpScale.value = Math.round(s*100); inpX.value = Math.round(refState.x); inpY.value = Math.round(refState.y);
                        updateRefVisuals();
                        document.getElementById('refTools').style.display = 'flex';
                        btnRefToggle.style.display = 'flex';
                        autoConvertImage();
                    }
                };
                r.readAsDataURL(input.files[0]);
            }
        }

        function updateRef(prop, val) {
            if (prop === 'scale') refState.scale = val/100;
            if (prop === 'x') refState.x = parseInt(val);
            if (prop === 'y') refState.y = parseInt(val);
            updateRefVisuals();
        }

        function updateRefVisuals() {
            refImg.style.transform = `translate(${refState.x}px, ${refState.y}px) scale(${refState.scale})`;
        }

        function adjustZoom(delta) { currentScale = Math.max(1, currentScale + delta); applyZoom(); }
        function applyZoom() { stage.style.transform = `scale(${currentScale})`; zoomLabel.innerText = currentScale + "x"; }
        function toggleGrid() { gridCanvas.style.display = gridCanvas.style.display === 'none' ? 'block' : 'none'; }
        function drawGrid() {
            gridCtx.clearRect(0,0,2560,1920); gridCtx.strokeStyle = "rgba(255,0,0,0.3)"; gridCtx.lineWidth = 1;
            for(let x=0; x<=256; x+=8) { gridCtx.beginPath(); gridCtx.moveTo(x*10,0); gridCtx.lineTo(x*10,1920); gridCtx.stroke(); }
            for(let y=0; y<=192; y+=8) { gridCtx.beginPath(); gridCtx.moveTo(0,y*10); gridCtx.lineTo(2560,y*10); gridCtx.stroke(); }
        }

        // --- SPECTRUM SYSTEM ---
        function parseBasic() {
            const code = document.getElementById('codeEditor').value; if (!code.trim()) return;
            ctx.clearRect(0, 0, 256, 192); attrData.fill(56);
            code.split('\n').forEach(line => {
                const match = line.match(/POKE\s+(\d+)\s*,\s*(\d+)/i);
                if(match) {
                    const addr = parseInt(match[1]), val = parseInt(match[2]);
                    if(addr >= 16384 && addr < 22528) {
                        const offset = addr - 16384, y = (((offset >> 11) & 3) << 6) | (((offset >> 5) & 7) << 3) | ((offset >> 8) & 7), xBase = (offset & 31) * 8;
                        for(let b=0; b<8; b++) { if(val & (1<<(7-b))) ctx.fillRect(xBase+b, y, 1, 1); }
                    } else if(addr >= 22528 && addr < 23296) { attrData[addr - 22528] = val; }
                }
            });
            redrawAttributes(); saveState();
        }

        function generateSpectrumMemory() {
            const memory = new Uint8Array(6912);
            const imgData = ctx.getImageData(0, 0, 256, 192).data;
            for (let y = 0; y < 192; y++) {
                let addr = ((y>>6&3)<<11) | ((y&7)<<8) | ((y>>3&7)<<5);
                for (let xByte = 0; xByte < 32; xByte++) {
                    let byteVal = 0;
                    for (let bit = 0; bit < 8; bit++) { if (imgData[((y * 256) + (xByte * 8) + bit) * 4 + 3] > 0) byteVal |= (1 << (7 - bit)); }
                    memory[addr + xByte] = byteVal;
                }
            }
            for (let i = 0; i < 768; i++) memory[6144 + i] = attrData[i];
            return memory;
        }

        function downloadBinTap() {
            const mem = generateSpectrumMemory();
            const blob = new Blob([new Uint8Array([19,0,0,3, ...Array.from("art       ").map(c=>c.charCodeAt(0)), 0,27,0,64,0,0,128, ...Array.from(mem)])], {type:"application/x-spectrum-tap"});
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = "art.tap"; a.click();
        }

        function downloadTzx() {
            const mem = generateSpectrumMemory();
            const blob = new Blob([new Uint8Array([0x5A,0x58,0x54,0x61,0x70,0x65,0x21,0x1A,0x01,0x14, 0x10,0,0,0,0,255, ...Array.from(mem)])], {type:"application/x-spectrum-tzx"});
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = "art.tzx"; a.click();
        }

        function saveState() { if (historyStack.length > 30) historyStack.shift(); historyStack.push({p: ctx.getImageData(0,0,256,192), a: [...attrData]}); }
        function undo() { if(historyStack.length < 2) return; historyStack.pop(); const s = historyStack[historyStack.length-1]; ctx.putImageData(s.p, 0,0); attrData = [...s.a]; redrawAttributes(); }
        function clearAll() { ctx.clearRect(0,0,256,192); attrData.fill(56); redrawAttributes(); saveState(); }

        init();
    </script>
</body>
</html>
