<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JV's TZX Master - Auto Convert</title>
    <style>
        body { 
            background: #181818; 
            color: #ccc; 
            font-family: 'Courier New', monospace; 
            text-align: center; 
            padding: 0; margin: 0;
            user-select: none;
        }

        .controls { 
            position: sticky; top: 0; z-index: 2000;
            background: #222; padding: 10px;
            border-bottom: 2px solid #444;
            display: flex; justify-content: center; gap: 15px; flex-wrap: wrap;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            align-items: center;
        }

        .toolbar-group {
            display: flex; gap: 5px; align-items: center; 
            background: #333; padding: 5px 10px; border-radius: 4px; border: 1px solid #555;
        }

        #stage-wrap {
            display: flex; justify-content: center; align-items: flex-start;
            width: 100%; min-height: 200px;
            padding-top: 40px; padding-bottom: 40px;
            overflow: auto;
            background-color: #2a2a2a; 
        }

        #stage {
            position: relative;
            width: 256px; height: 192px;
            background-color: #fff;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            transform-origin: top center;
            image-rendering: pixelated; 
            overflow: hidden; 
        }

        #refContainer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 0; }
        #refImg { position: absolute; top: 0; left: 0; transform-origin: top left; opacity: 0.5; }
        #attrCanvas { position: absolute; top: 0; left: 0; z-index: 1; pointer-events: none; opacity: 0.7; }
        #speccyCanvas { position: absolute; top: 0; left: 0; z-index: 2; width: 256px; height: 192px; opacity: 1.0; cursor: crosshair; }
        #gridCanvas { position: absolute; top: 0; left: 0; z-index: 3; pointer-events: none; width: 256px; height: 192px; }

        .color-swatch { width: 20px; height: 20px; border: 2px solid #555; cursor: pointer; }
        .color-swatch.active { border-color: #fff; transform: scale(1.2); box-shadow: 0 0 5px #fff; }
        
        .tool-btn { padding: 5px 10px; cursor: pointer; border: 1px solid #555; background: #444; color: #fff; }
        .tool-btn.active { background: #2e7d32; border-color: #00e676; }
        
        button { cursor: pointer; padding: 6px 12px; background: #444; color: #fff; border: 1px solid #666; font-weight: bold; font-size: 13px; }
        button:hover { background: #666; }

        .ref-controls { display: none; gap: 5px; font-size: 11px; align-items: center; color: #aaa; }
        .ref-controls input { width: 45px; background: #111; color: #fff; border: 1px solid #444; padding: 2px; }

        .editor-wrap { display: flex; justify-content: center; padding: 20px; background: #181818; }
        textarea { 
            width: 80%; max-width: 900px; height: 300px; 
            background: #000; color: #0f0; 
            border: 1px solid #555; padding: 20px; 
            font-size: 14px; font-family: 'Courier New', monospace;
            white-space: pre; overflow: auto;
        }
    </style>
</head>
<body>

    <div class="controls">
        <div class="toolbar-group">
            <button onclick="adjustZoom(-1)">-</button>
            <span id="zoomLabel" style="width:30px; text-align:center">10x</span>
            <button onclick="adjustZoom(1)">+</button>
        </div>

        <div class="toolbar-group">
            <button id="btnPencil" class="tool-btn active" onclick="setTool('pencil')">‚úèÔ∏è PIX</button>
            <button id="btnBrush" class="tool-btn" onclick="setTool('brush')">üñåÔ∏è COL</button>
            <button id="btnMove" class="tool-btn" onclick="setTool('mover')">‚úã MOV</button>
            <button onclick="undo()">‚Ü©Ô∏è UNDO</button>
        </div>

        <div class="toolbar-group" style="border: 1px solid #0277bd;">
            <label for="fileInput" class="tool-btn" style="background:#01579b; margin:0;">üìÇ CONVERT PHOTO</label>
            <input type="file" id="fileInput" style="display:none" accept="image/*" onchange="loadRef(this)">
            <button id="btnRefToggle" onclick="toggleRef()" style="display:none; padding:5px 8px; background:#0288d1; border-color:#29b6f6;">üëÅÔ∏è</button>
            <div id="refTools" class="ref-controls">
                <span>SC:</span><input id="inpScale" type="number" value="100" step="5" oninput="updateRef('scale', this.value)">
                <span>X:</span><input id="inpX" type="number" value="0" step="1" oninput="updateRef('x', this.value)">
                <span>Y:</span><input id="inpY" type="number" value="0" step="1" oninput="updateRef('y', this.value)">
            </div>
        </div>

        <div class="toolbar-group">
            <div class="color-swatch" style="background:#000000" onclick="setColor(0)"></div>
            <div class="color-swatch" style="background:#0000D7" onclick="setColor(1)"></div>
            <div class="color-swatch" style="background:#D70000" onclick="setColor(2)"></div>
            <div class="color-swatch" style="background:#D700D7" onclick="setColor(3)"></div>
            <div class="color-swatch" style="background:#00D700" onclick="setColor(4)"></div>
            <div class="color-swatch" style="background:#00D7D7" onclick="setColor(5)"></div>
            <div class="color-swatch" style="background:#D7D700" onclick="setColor(6)"></div>
            <div class="color-swatch" style="background:#FFFFFF" onclick="setColor(7)"></div>
        </div>

        <div class="toolbar-group">
            <button onclick="toggleGrid()"># GRID</button>
            <button onclick="clearAll()">üóëÔ∏è CLR</button>
        </div>
        
        <div class="toolbar-group" style="border-color: #4caf50;">
            <button onclick="parseBasic()" style="background:#1565c0; border-color:#0d47a1;">üîÑ IMPORT</button>
            <button onclick="downloadBinTap()" style="background:#2e7d32; border-color:#1b5e20;">üíæ TAP</button>
            <button onclick="downloadTzx()" style="background:#c62828; border-color:#b71c1c;">üìº TZX</button>
        </div>
    </div>

    <div id="stage-wrap">
        <div id="stage">
            <div id="refContainer"><img id="refImg" src="" alt=""></div>
            <canvas id="attrCanvas" width="256" height="192"></canvas>
            <canvas id="speccyCanvas" width="256" height="192"></canvas>
            <canvas id="gridCanvas" width="2560" height="1920"></canvas>
        </div>
    </div>

    <div class="editor-wrap">
        <textarea id="codeEditor" placeholder="Paste BASIC POKEs here to import..."></textarea>
    </div>

    <script>
        const speccyCanvas = document.getElementById('speccyCanvas');
        const ctx = speccyCanvas.getContext('2d', {willReadFrequently: true});
        const attrCanvas = document.getElementById('attrCanvas');
        const attrCtx = attrCanvas.getContext('2d');
        const gridCanvas = document.getElementById('gridCanvas');
        const gridCtx = gridCanvas.getContext('2d');
        const editor = document.getElementById('codeEditor');
        const stage = document.getElementById('stage');
        const stageWrap = document.getElementById('stage-wrap');
        const zoomLabel = document.getElementById('zoomLabel');
        const refContainer = document.getElementById('refContainer');
        const refImg = document.getElementById('refImg');
        const refTools = document.getElementById('refTools');
        const btnRefToggle = document.getElementById('btnRefToggle');
        const inpScale = document.getElementById('inpScale');
        const inpX = document.getElementById('inpX');
        const inpY = document.getElementById('inpY');
        
        let refState = { opacity: 0.5, scale: 1.0, x: 0, y: 0, visible: true };
        let currentScale = 10;
        let activeTool = 'pencil';
        let activeColor = 0;
        let isDrawing = false;
        let gridVisible = true;
        let historyStack = [];
        let attrData = new Array(768).fill(56); 
        let isDraggingRef = false;
        let lastDragX = 0, lastDragY = 0;
        const PALETTE = ['#000000', '#0000D7', '#D70000', '#D700D7', '#00D700', '#00D7D7', '#D7D700', '#FFFFFF'];

        function init() { applyZoom(); drawGrid(); saveState(); }

        // --- CONVERSION ENGINE ---
        function autoConvertImage() {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = 256; tempCanvas.height = 192;
            const tCtx = tempCanvas.getContext('2d');
            tCtx.fillStyle = "white";
            tCtx.fillRect(0, 0, 256, 192);
            const drawW = refImg.naturalWidth * refState.scale;
            const drawH = refImg.naturalHeight * refState.scale;
            tCtx.drawImage(refImg, refState.x, refState.y, drawW, drawH);
            const pixels = tCtx.getImageData(0, 0, 256, 192).data;

            ctx.clearRect(0, 0, 256, 192);
            for (let by = 0; by < 24; by++) {
                for (let bx = 0; bx < 32; bx++) {
                    processBlock(bx, by, pixels);
                }
            }
            redrawAttributes();
            saveState();
        }

        function processBlock(bx, by, pixels) {
            let blockColors = [];
            for (let py = 0; py < 8; py++) {
                for (let px = 0; px < 8; px++) {
                    const idx = (((by * 8 + py) * 256) + (bx * 8 + px)) * 4;
                    const r = pixels[idx], g = pixels[idx+1], b = pixels[idx+2];
                    const brightness = (r * 0.299 + g * 0.587 + b * 0.114);
                    if (brightness < 128) {
                        ctx.fillStyle = "black";
                        ctx.fillRect(bx * 8 + px, by * 8 + py, 1, 1);
                    }
                    blockColors.push(getNearestSpeccyColor(r, g, b));
                }
            }
            const counts = {};
            blockColors.forEach(c => counts[c] = (counts[c] || 0) + 1);
            const sorted = Object.keys(counts).sort((a, b) => counts[b] - counts[a]);
            attrData[by * 32 + bx] = (parseInt(sorted[0]) * 8);
        }

        function getNearestSpeccyColor(r, g, b) {
            let minDist = Infinity, bestIndex = 0;
            const specRGB = [[0,0,0], [0,0,215], [215,0,0], [215,0,215], [0,215,0], [0,215,215], [215,215,0], [255,255,255]];
            specRGB.forEach((rgb, i) => {
                const d = Math.sqrt((r-rgb[0])**2 + (g-rgb[1])**2 + (b-rgb[2])**2);
                if (d < minDist) { minDist = d; bestIndex = i; }
            });
            return bestIndex;
        }

        // --- IMPORT ENGINE ---
        function parseBasic() {
            const code = editor.value;
            if (!code.trim()) { alert("Paste some BASIC code first!"); return; }
            ctx.clearRect(0, 0, 256, 192); attrData.fill(56);
            const lines = code.split('\n'); let pokeCount = 0;
            lines.forEach(line => {
                const match = line.match(/POKE\s+(\d+)\s*,\s*(\d+)/i);
                if(match) {
                    const addr = parseInt(match[1]); const val = parseInt(match[2]);
                    if(addr >= 16384 && addr < 22528) {
                        const offset = addr - 16384; const y = (((offset >> 11) & 3) << 6) | (((offset >> 5) & 7) << 3) | ((offset >> 8) & 7);
                        const xBase = (offset & 31) * 8;
                        for(let b=0; b<8; b++) { if(val & (1<<(7-b))) ctx.fillRect(xBase+b, y, 1, 1); }
                        pokeCount++;
                    } else if(addr >= 22528 && addr < 23296) { attrData[addr - 22528] = val; pokeCount++; }
                }
            });
            redrawAttributes(); saveState(); alert(`Imported ${pokeCount} POKE commands!`);
        }

        // --- DATA GENERATORS ---
        function getBasicBytes() {
            const tokens = [0xEF, 0x22, 0x22, 0xAA, 0x0D];
            let lineBytes = [0x00, 0x0A]; 
            lineBytes.push(tokens.length & 0xFF); lineBytes.push((tokens.length >> 8) & 0xFF);
            tokens.forEach(t => lineBytes.push(t));
            return lineBytes;
        }

        function generateSpectrumMemory() {
            const memory = new Uint8Array(6912);
            const imgData = ctx.getImageData(0, 0, 256, 192).data;
            for (let y = 0; y < 192; y++) {
                let vY = y; let address = ((vY>>6&3)<<11) | ((vY&7)<<8) | ((vY>>3&7)<<5);
                for (let xByte = 0; xByte < 32; xByte++) {
                    let byteVal = 0;
                    for (let bit = 0; bit < 8; bit++) {
                        if (imgData[((y * 256) + (xByte * 8) + bit) * 4 + 3] > 0) byteVal |= (1 << (7 - bit));
                    }
                    memory[address + xByte] = byteVal;
                }
            }
            for (let i = 0; i < 768; i++) memory[6144 + i] = attrData[i];
            return memory;
        }

        // --- TAP ENGINE ---
        function createTapBlock(flag, data) {
            let block = [];
            let len = data.length + 2;
            block.push(len & 0xFF); block.push((len >> 8) & 0xFF);
            block.push(flag); let checksum = flag;
            for(let b of data) { block.push(b); checksum ^= b; }
            block.push(checksum); return block;
        }
        function createHeader(type, name, len, param1, param2) {
            let h = [type];
            for(let i=0; i<10; i++) h.push(i < name.length ? name.charCodeAt(i) : 32);
            h.push(len & 0xFF); h.push((len >> 8) & 0xFF);
            h.push(param1 & 0xFF); h.push((param1 >> 8) & 0xFF);
            h.push(param2 & 0xFF); h.push((param2 >> 8) & 0xFF);
            return h;
        }

        function downloadBinTap() {
            const basicBytes = getBasicBytes();
            const screenBytes = generateSpectrumMemory();
            let tapData = [];
            tapData = tapData.concat(createTapBlock(0x00, createHeader(0, "loader", basicBytes.length, 10, basicBytes.length)));
            tapData = tapData.concat(createTapBlock(0xFF, basicBytes));
            tapData = tapData.concat(createTapBlock(0x00, createHeader(3, "art", 6912, 16384, 32768)));
            tapData = tapData.concat(createTapBlock(0xFF, screenBytes));
            const blob = new Blob([new Uint8Array(tapData)], { type: "application/x-spectrum-tap" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = "pixel_art.tap"; a.click();
        }

        // --- TZX ENGINE ---
        function downloadTzx() {
            const basicBytes = getBasicBytes();
            const screenBytes = generateSpectrumMemory();
            let tzxData = [];
            const tzxHeader = [0x5A, 0x58, 0x54, 0x61, 0x70, 0x65, 0x21, 0x1A, 0x01, 0x14];
            tzxData = tzxData.concat(tzxHeader);
            function addTzxBlock(flag, data, pauseMs) {
                tzxData.push(0x10);
                tzxData.push(pauseMs & 0xFF); tzxData.push((pauseMs >> 8) & 0xFF);
                let len = data.length + 2;
                tzxData.push(len & 0xFF); tzxData.push((len >> 8) & 0xFF);
                tzxData.push(flag);
                let checksum = flag;
                data.forEach(b => { tzxData.push(b); checksum ^= b; });
                tzxData.push(checksum);
            }
            addTzxBlock(0x00, createHeader(0, "loader", basicBytes.length, 10, basicBytes.length), 1000);
            addTzxBlock(0xFF, basicBytes, 1000);
            addTzxBlock(0x00, createHeader(3, "art", 6912, 16384, 32768), 1000);
            addTzxBlock(0xFF, screenBytes, 2000);
            const blob = new Blob([new Uint8Array(tzxData)], { type: "application/x-spectrum-tzx" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = "retro_art.tzx"; a.click();
        }

        // --- APP LOGIC ---
        function getPos(e) {
            const rect = speccyCanvas.getBoundingClientRect();
            const scaleX = speccyCanvas.width / rect.width; const scaleY = speccyCanvas.height / rect.height;
            return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY, gridX: Math.floor((e.clientX - rect.left) * scaleX), gridY: Math.floor((e.clientY - rect.top) * scaleY) };
        }
        speccyCanvas.onmousedown = (e) => { const pos = getPos(e); if (activeTool === 'mover') { isDraggingRef = true; lastDragX = pos.x; lastDragY = pos.y; } else { isDrawing = true; useTool(e); } };
        window.onmouseup = () => { if (isDraggingRef) isDraggingRef = false; if (isDrawing) { isDrawing = false; saveState(); } };
        speccyCanvas.onmousemove = (e) => { const pos = getPos(e); if (isDraggingRef && activeTool === 'mover') { refState.x += (pos.x - lastDragX); refState.y += (pos.y - lastDragY); inpX.value = Math.round(refState.x); inpY.value = Math.round(refState.y); updateRefVisuals(); lastDragX = pos.x; lastDragY = pos.y; } else if (isDrawing) { useTool(e); } };
        
        function useTool(e) {
            const pos = getPos(e);
            if (activeTool === 'pencil') { ctx.fillStyle = "black"; ctx.fillRect(pos.gridX, pos.gridY, 1, 1); } 
            else if (activeTool === 'brush') { const gx = Math.floor(pos.gridX / 8); const gy = Math.floor(pos.gridY / 8); if (gx >= 0 && gx < 32 && gy >= 0 && gy < 24) { attrData[gy * 32 + gx] = (activeColor * 8); redrawAttributes(); } }
        }
        function redrawAttributes() {
            attrCtx.clearRect(0, 0, 256, 192); for (let i = 0; i < 768; i++) { const paper = (attrData[i] >> 3) & 7; if (paper !== 7) { attrCtx.fillStyle = PALETTE[paper]; attrCtx.fillRect((i % 32) * 8, Math.floor(i / 32) * 8, 8, 8); } }
        }
        function adjustZoom(delta) { currentScale += delta; if (currentScale < 1) currentScale = 1; if (currentScale > 20) currentScale = 20; applyZoom(); }
        function applyZoom() { stage.style.transform = `scale(${currentScale})`; zoomLabel.innerText = currentScale + "x"; stageWrap.style.height = (192 * currentScale + 100) + "px"; }
        function toggleGrid() { gridVisible = !gridVisible; if (gridVisible) drawGrid(); else gridCtx.clearRect(0, 0, 2560, 1920); }
        function drawGrid() {
            gridCtx.clearRect(0, 0, 2560, 1920); const scale = 10;
            for (let x = 0; x <= 256; x+=8) { gridCtx.beginPath(); gridCtx.strokeStyle = "rgba(255, 0, 0, 0.4)"; gridCtx.lineWidth = 2; gridCtx.moveTo(x*scale, 0); gridCtx.lineTo(x*scale, 1920); gridCtx.stroke(); }
            for (let y = 0; y <= 192; y+=8) { gridCtx.beginPath(); gridCtx.strokeStyle = "rgba(255, 0, 0, 0.4)"; gridCtx.lineWidth = 2; gridCtx.moveTo(0, y*scale); gridCtx.lineTo(2560, y*scale); gridCtx.stroke(); }
        }
        function saveState() { if (historyStack.length > 30) historyStack.shift(); historyStack.push({ pixels: ctx.getImageData(0, 0, 256, 192), attrs: [...attrData] }); }
        function undo() { if (historyStack.length <= 1) return; historyStack.pop(); const prev = historyStack[historyStack.length - 1]; ctx.putImageData(prev.pixels, 0, 0); attrData = [...prev.attrs]; redrawAttributes(); }
        function clearAll() { ctx.clearRect(0, 0, 256, 192); attrCtx.clearRect(0, 0, 256, 192); attrData.fill(56); saveState(); }
        
        function loadRef(input) { 
            if (input.files && input.files[0]) { 
                const r = new FileReader(); 
                r.onload = function(e) { 
                    refImg.src = e.target.result; 
                    refImg.onload = function() { 
                        const w=refImg.naturalWidth, h=refImg.naturalHeight; 
                        const s=Math.min(256/w, 192/h); 
                        refState={scale:s, x:(256-w*s)/2, y:(192-h*s)/2, opacity:0.5, visible:true}; 
                        updateRefVisuals(); 
                        setTimeout(() => { autoConvertImage(); }, 100);
                        refTools.style.display='flex'; btnRefToggle.style.display='block'; 
                        inpScale.value=Math.round(s*100); inpX.value=Math.round(refState.x); inpY.value=Math.round(refState.y); 
                    } 
                }; 
                r.readAsDataURL(input.files[0]); 
            } 
        }

        function toggleRef() { refState.visible = !refState.visible; refContainer.style.display = refState.visible ? 'block' : 'none'; btnRefToggle.innerText = refState.visible ? 'üëÅÔ∏è' : 'üö´'; }
        function updateRef(prop, val) { if (prop === 'opacity') refState.opacity = val/100; if (prop === 'scale') refState.scale = val/100; if (prop === 'x') refState.x = parseInt(val); if (prop === 'y') refState.y = parseInt(val); updateRefVisuals(); }
        function updateRefVisuals() { refImg.style.opacity = refState.opacity; refImg.style.transform = `translate(${refState.x}px, ${refState.y}px) scale(${refState.scale})`; }
        function setTool(t) { activeTool=t; document.getElementById('btnPencil').className = t==='pencil'?'tool-btn active':'tool-btn'; document.getElementById('btnBrush').className = t==='brush'?'tool-btn active':'tool-btn'; document.getElementById('btnMove').className = t==='mover'?'tool-btn active':'tool-btn'; speccyCanvas.style.cursor = t === 'mover' ? 'move' : 'crosshair'; }
        function setColor(c) { activeColor=c; document.querySelectorAll('.color-swatch').forEach((e,i)=>e.className=i===c?'color-swatch active':'color-swatch'); setTool('brush'); }
        document.addEventListener('keydown', e => { if((e.ctrlKey||e.metaKey) && e.key==='z'){e.preventDefault(); undo();} });

        init();
    </script>
</body>
</html>
