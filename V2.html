<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JV's TZX Master - Spectrum Rubber Key Edition</title>
    <style>
        body { 
            background: #1a1a1b; 
            color: #ccc; 
            font-family: 'Courier New', monospace; 
            margin: 0; padding: 0;
            display: flex; height: 100vh; overflow: hidden;
        }

        /* LEFT SIDEBAR - The Photoshop Tool Style */
        .sidebar {
            width: 70px;
            background: #252526;
            border-right: 2px solid #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 15px;
            gap: 12px;
            z-index: 100;
        }

        /* RUBBER KEY BUTTONS */
        .rubber-key {
            width: 50px;
            height: 45px;
            background: #3d3d3d;
            border-radius: 6px;
            border: none;
            border-bottom: 4px solid #111;
            border-right: 2px solid #222;
            color: #fff;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: all 0.05s;
        }

        .rubber-key:active, .rubber-key.active {
            transform: translateY(3px);
            border-bottom: 1px solid #000;
            background: #222;
            color: #00ff00;
        }

        .rubber-key span { font-size: 18px; margin-bottom: 2px; }

        /* MAIN CANVAS AREA */
        #workspace {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            background: #2a2a2a;
        }

        .top-info {
            background: #333;
            padding: 8px 20px;
            display: flex;
            gap: 20px;
            align-items: center;
            border-bottom: 1px solid #000;
            font-size: 12px;
        }

        #stage-wrap {
            flex-grow: 1;
            overflow: auto;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding-top: 50px;
            background-image: 
                linear-gradient(45deg, #222 25%, transparent 25%), 
                linear-gradient(-45deg, #222 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #222 75%),
                linear-gradient(-45deg, transparent 75%, #222 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        #stage {
            position: relative;
            width: 256px; height: 192px;
            background: #fff;
            box-shadow: 0 0 40px rgba(0,0,0,0.8);
            transform-origin: top center;
            image-rendering: pixelated;
        }

        /* COLOR SWATCHES IN SIDEBAR */
        .swatch-box {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
            padding: 5px;
            background: #111;
            border-radius: 4px;
        }
        .color-swatch { width: 18px; height: 18px; border: 1px solid #444; cursor: pointer; }
        .color-swatch.active { border: 2px solid white; box-shadow: 0 0 5px white; }

        /* RIGHT PANEL FOR TEXT */
        .right-panel {
            width: 280px;
            background: #252526;
            border-left: 2px solid #000;
            display: flex;
            flex-direction: column;
            padding: 10px;
        }

        textarea {
            flex-grow: 1;
            background: #000;
            color: #0f0;
            border: 1px solid #444;
            font-family: 'Courier New', monospace;
            padding: 10px;
            font-size: 12px;
        }

        .spectrum-brand {
            height: 10px;
            background: linear-gradient(to right, #ff0000 25%, #ffff00 25%, #ffff00 50%, #00ff00 50%, #00ff00 75%, #0000ff 75%);
            margin: 10px 0;
        }

        canvas { position: absolute; top: 0; left: 0; }
        #speccyCanvas { z-index: 10; cursor: crosshair; }
        #gridCanvas { z-index: 11; pointer-events: none; }
        #refImg { position: absolute; top: 0; left: 0; transform-origin: top left; }

        .hidden-file { display: none; }
    </style>
</head>
<body>

    <div class="sidebar">
        <button id="btnPencil" class="rubber-key active" onclick="setTool('pencil')"><span>‚úé</span>PIX</button>
        <button id="btnBrush" class="rubber-key" onclick="setTool('brush')"><span>‚ñß</span>COL</button>
        <button id="btnMove" class="rubber-key" onclick="setTool('mover')"><span>‚úã</span>MOV</button>
        
        <div class="swatch-box">
            <div class="color-swatch" style="background:#000000" onclick="setColor(0)"></div>
            <div class="color-swatch" style="background:#0000D7" onclick="setColor(1)"></div>
            <div class="color-swatch" style="background:#D70000" onclick="setColor(2)"></div>
            <div class="color-swatch" style="background:#D700D7" onclick="setColor(3)"></div>
            <div class="color-swatch" style="background:#00D700" onclick="setColor(4)"></div>
            <div class="color-swatch" style="background:#00D7D7" onclick="setColor(5)"></div>
            <div class="color-swatch" style="background:#D7D700" onclick="setColor(6)"></div>
            <div class="color-swatch" style="background:#FFFFFF" onclick="setColor(7)"></div>
        </div>

        <button class="rubber-key" onclick="undo()"><span>‚Ü∂</span>UNDO</button>
        <button class="rubber-key" onclick="toggleGrid()"><span>#</span>GRID</button>
        <button class="rubber-key" onclick="clearAll()"><span>üóë</span>CLR</button>
    </div>

    <div id="workspace">
        <div class="top-info">
            <div><strong>JV's TZX MASTER</strong></div>
            <div style="display:flex; align-items:center; gap:5px">
                Zoom: <button onclick="adjustZoom(-1)">-</button>
                <span id="zoomLabel" style="width:30px;text-align:center">10x</span>
                <button onclick="adjustZoom(1)">+</button>
            </div>
            <div id="refTools" style="display:none; gap:10px">
                <button id="btnRefToggle" onclick="toggleRef()">üëÅ REF</button>
                SC: <input id="inpScale" type="number" value="100" style="width:50px" oninput="updateRef('scale', this.value)">
                X: <input id="inpX" type="number" value="0" style="width:40px" oninput="updateRef('x', this.value)">
                Y: <input id="inpY" type="number" value="0" style="width:40px" oninput="updateRef('y', this.value)">
            </div>
        </div>

        <div id="stage-wrap">
            <div id="stage">
                <div id="refContainer"><img id="refImg" src="" alt=""></div>
                <canvas id="attrCanvas" width="256" height="192"></canvas>
                <canvas id="speccyCanvas" width="256" height="192"></canvas>
                <canvas id="gridCanvas" width="2560" height="1920"></canvas>
            </div>
        </div>
    </div>

    <div class="right-panel">
        <div class="spectrum-brand"></div>
        <label style="font-size:10px; color:#888">ZX BASIC POKES / INPUT</label>
        <textarea id="codeEditor" placeholder="Paste BASIC here..."></textarea>
        
        <div style="margin-top:10px; display:flex; flex-direction:column; gap:5px">
            <label for="fileInput" class="rubber-key" style="width:100%; height:35px">üìÇ LOAD IMAGE</label>
            <input type="file" id="fileInput" class="hidden-file" accept="image/*" onchange="loadRef(this)">
            
            <button onclick="parseBasic()" style="background:#0055aa; border:none; padding:8px; color:white; cursor:pointer">üîÑ IMPORT POKES</button>
            
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:5px">
                <button onclick="downloadBinTap()" style="background:#2e7d32; border:none; padding:8px; color:white; cursor:pointer">üíæ TAP</button>
                <button onclick="downloadTzx()" style="background:#c62828; border:none; padding:8px; color:white; cursor:pointer">üìº TZX</button>
            </div>
        </div>
    </div>

    <script>
        // --- ALL JS LOGIC FROM ORIGINAL PRESERVED ---
        const speccyCanvas = document.getElementById('speccyCanvas');
        const ctx = speccyCanvas.getContext('2d', {willReadFrequently: true});
        const attrCanvas = document.getElementById('attrCanvas');
        const attrCtx = attrCanvas.getContext('2d');
        const gridCanvas = document.getElementById('gridCanvas');
        const gridCtx = gridCanvas.getContext('2d');
        const editor = document.getElementById('codeEditor');
        const stage = document.getElementById('stage');
        const zoomLabel = document.getElementById('zoomLabel');
        const refImg = document.getElementById('refImg');
        const refTools = document.getElementById('refTools');
        const inpScale = document.getElementById('inpScale');
        const inpX = document.getElementById('inpX');
        const inpY = document.getElementById('inpY');
        
        let refState = { opacity: 0.5, scale: 1.0, x: 0, y: 0, visible: true };
        let currentScale = 10;
        let activeTool = 'pencil';
        let activeColor = 0;
        let isDrawing = false;
        let gridVisible = true;
        let historyStack = [];
        let attrData = new Array(768).fill(56); 
        let isDraggingRef = false;
        let lastDragX = 0, lastDragY = 0;
        const PALETTE = ['#000000', '#0000D7', '#D70000', '#D700D7', '#00D700', '#00D7D7', '#D7D700', '#FFFFFF'];

        function init() { applyZoom(); drawGrid(); saveState(); }

        function getPos(e) {
            const rect = speccyCanvas.getBoundingClientRect();
            const scaleX = 256 / rect.width; const scaleY = 192 / rect.height;
            return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY, gridX: Math.floor((e.clientX - rect.left) * scaleX), gridY: Math.floor((e.clientY - rect.top) * scaleY) };
        }

        speccyCanvas.onmousedown = (e) => { const pos = getPos(e); if (activeTool === 'mover') { isDraggingRef = true; lastDragX = pos.x; lastDragY = pos.y; } else { isDrawing = true; useTool(e); } };
        window.onmouseup = () => { if (isDraggingRef) isDraggingRef = false; if (isDrawing) { isDrawing = false; saveState(); } };
        speccyCanvas.onmousemove = (e) => { const pos = getPos(e); if (isDraggingRef && activeTool === 'mover') { refState.x += (pos.x - lastDragX); refState.y += (pos.y - lastDragY); inpX.value = Math.round(refState.x); inpY.value = Math.round(refState.y); updateRefVisuals(); lastDragX = pos.x; lastDragY = pos.y; } else if (isDrawing) { useTool(e); } };
        
        function useTool(e) {
            const pos = getPos(e);
            if (activeTool === 'pencil') { ctx.fillStyle = "black"; ctx.fillRect(pos.gridX, pos.gridY, 1, 1); } 
            else if (activeTool === 'brush') { const gx = Math.floor(pos.gridX / 8); const gy = Math.floor(pos.gridY / 8); if (gx >= 0 && gx < 32 && gy >= 0 && gy < 24) { attrData[gy * 32 + gx] = (activeColor * 8); redrawAttributes(); } }
        }

        function redrawAttributes() {
            attrCtx.clearRect(0, 0, 256, 192); for (let i = 0; i < 768; i++) { const paper = (attrData[i] >> 3) & 7; if (paper !== 7) { attrCtx.fillStyle = PALETTE[paper]; attrCtx.fillRect((i % 32) * 8, Math.floor(i / 32) * 8, 8, 8); } }
        }

        function adjustZoom(delta) { currentScale += delta; if (currentScale < 1) currentScale = 1; if (currentScale > 20) currentScale = 20; applyZoom(); }
        function applyZoom() { stage.style.transform = `scale(${currentScale})`; zoomLabel.innerText = currentScale + "x"; }
        function toggleGrid() { gridVisible = !gridVisible; if (gridVisible) drawGrid(); else gridCtx.clearRect(0, 0, 2560, 1920); }
        function drawGrid() {
            gridCtx.clearRect(0, 0, 2560, 1920); const scale = 10;
            for (let x = 0; x <= 256; x+=8) { gridCtx.beginPath(); gridCtx.strokeStyle = "rgba(255, 0, 0, 0.4)"; gridCtx.lineWidth = 2; gridCtx.moveTo(x*scale, 0); gridCtx.lineTo(x*scale, 1920); gridCtx.stroke(); }
            for (let y = 0; y <= 192; y+=8) { gridCtx.beginPath(); gridCtx.strokeStyle = "rgba(255, 0, 0, 0.4)"; gridCtx.lineWidth = 2; gridCtx.moveTo(0, y*scale); gridCtx.lineTo(2560, y*scale); gridCtx.stroke(); }
        }

        function setTool(t) { 
            activeTool=t; 
            document.querySelectorAll('.rubber-key').forEach(b => b.classList.remove('active'));
            if(t==='pencil') document.getElementById('btnPencil').classList.add('active');
            if(t==='brush') document.getElementById('btnBrush').classList.add('active');
            if(t==='mover') document.getElementById('btnMove').classList.add('active');
            speccyCanvas.style.cursor = t === 'mover' ? 'move' : 'crosshair'; 
        }

        function setColor(c) { 
            activeColor=c; 
            document.querySelectorAll('.color-swatch').forEach((e,i)=>e.classList.toggle('active', i===c));
            setTool('brush'); 
        }

        function loadRef(input) { 
            if (input.files && input.files[0]) { 
                const r = new FileReader(); 
                r.onload = function(e) { 
                    refImg.src = e.target.result; 
                    refImg.onload = function() { 
                        const w=refImg.naturalWidth, h=refImg.naturalHeight; 
                        const s=Math.min(256/w, 192/h); 
                        refState={scale:s, x:(256-w*s)/2, y:(192-h*s)/2, opacity:0.5, visible:true}; 
                        updateRefVisuals(); 
                        setTimeout(() => { autoConvertImage(); }, 100);
                        refTools.style.display='flex';
                        inpScale.value=Math.round(s*100); inpX.value=Math.round(refState.x); inpY.value=Math.round(refState.y); 
                    } 
                }; 
                r.readAsDataURL(input.files[0]); 
            } 
        }

        function updateRefVisuals() { refImg.style.opacity = refState.opacity; refImg.style.transform = `translate(${refState.x}px, ${refState.y}px) scale(${refState.scale})`; }
        function autoConvertImage() {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = 256; tempCanvas.height = 192;
            const tCtx = tempCanvas.getContext('2d');
            tCtx.fillStyle = "white"; tCtx.fillRect(0, 0, 256, 192);
            tCtx.drawImage(refImg, refState.x, refState.y, refImg.naturalWidth * refState.scale, refImg.naturalHeight * refState.scale);
            const pixels = tCtx.getImageData(0, 0, 256, 192).data;
            ctx.clearRect(0, 0, 256, 192);
            for (let by = 0; by < 24; by++) { for (let bx = 0; bx < 32; bx++) { processBlock(bx, by, pixels); } }
            redrawAttributes(); saveState();
        }

        function processBlock(bx, by, pixels) {
            let blockColors = [];
            for (let py = 0; py < 8; py++) {
                for (let px = 0; px < 8; px++) {
                    const idx = (((by * 8 + py) * 256) + (bx * 8 + px)) * 4;
                    const brightness = (pixels[idx] * 0.299 + pixels[idx+1] * 0.587 + pixels[idx+2] * 0.114);
                    if (brightness < 128) { ctx.fillStyle = "black"; ctx.fillRect(bx * 8 + px, by * 8 + py, 1, 1); }
                    blockColors.push(getNearestSpeccyColor(pixels[idx], pixels[idx+1], pixels[idx+2]));
                }
            }
            const counts = {};
            blockColors.forEach(c => counts[c] = (counts[c] || 0) + 1);
            const sorted = Object.keys(counts).sort((a, b) => counts[b] - counts[a]);
            attrData[by * 32 + bx] = (parseInt(sorted[0]) * 8);
        }

        function getNearestSpeccyColor(r, g, b) {
            let minDist = Infinity, bestIndex = 0;
            const specRGB = [[0,0,0], [0,0,215], [215,0,0], [215,0,215], [0,215,0], [0,215,215], [215,215,0], [255,255,255]];
            specRGB.forEach((rgb, i) => {
                const d = Math.sqrt((r-rgb[0])**2 + (g-rgb[1])**2 + (b-rgb[2])**2);
                if (d < minDist) { minDist = d; bestIndex = i; }
            });
            return bestIndex;
        }

        function parseBasic() {
            const code = editor.value; if (!code.trim()) return;
            ctx.clearRect(0, 0, 256, 192); attrData.fill(56);
            const lines = code.split('\n');
            lines.forEach(line => {
                const match = line.match(/POKE\s+(\d+)\s*,\s*(\d+)/i);
                if(match) {
                    const addr = parseInt(match[1]), val = parseInt(match[2]);
                    if(addr >= 16384 && addr < 22528) {
                        const offset = addr - 16384, y = (((offset >> 11) & 3) << 6) | (((offset >> 5) & 7) << 3) | ((offset >> 8) & 7), xBase = (offset & 31) * 8;
                        for(let b=0; b<8; b++) { if(val & (1<<(7-b))) ctx.fillRect(xBase+b, y, 1, 1); }
                    } else if(addr >= 22528 && addr < 23296) { attrData[addr - 22528] = val; }
                }
            });
            redrawAttributes(); saveState();
        }

        function generateSpectrumMemory() {
            const memory = new Uint8Array(6912);
            const imgData = ctx.getImageData(0, 0, 256, 192).data;
            for (let y = 0; y < 192; y++) {
                let addr = ((y>>6&3)<<11) | ((y&7)<<8) | ((y>>3&7)<<5);
                for (let xByte = 0; xByte < 32; xByte++) {
                    let byteVal = 0;
                    for (let bit = 0; bit < 8; bit++) { if (imgData[((y * 256) + (xByte * 8) + bit) * 4 + 3] > 0) byteVal |= (1 << (7 - bit)); }
                    memory[addr + xByte] = byteVal;
                }
            }
            for (let i = 0; i < 768; i++) memory[6144 + i] = attrData[i];
            return memory;
        }

        function downloadBinTap() {
            const screenBytes = generateSpectrumMemory();
            const header = [0, ...Array.from("art       ").map(c=>c.charCodeAt(0)), 0, 27, 0, 64, 0, 0, 128]; // Minimal header
            let tapData = [19, 0, 0, ...header, 0, 0, 27, 27, 0, 255, ...Array.from(screenBytes), 0]; // Placeholder checksum logic
            const blob = new Blob([new Uint8Array(tapData)], { type: "application/x-spectrum-tap" });
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = "art.tap"; a.click();
        }

        function downloadTzx() {
            const screenBytes = generateSpectrumMemory();
            let tzxData = [0x5A, 0x58, 0x54, 0x61, 0x70, 0x65, 0x21, 0x1A, 0x01, 0x14, 0x10, 0, 0, 0, 0, 255, ...Array.from(screenBytes), 0];
            const blob = new Blob([new Uint8Array(tzxData)], { type: "application/x-spectrum-tzx" });
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = "art.tzx"; a.click();
        }

        function updateRef(prop, val) { if (prop === 'scale') refState.scale = val/100; if (prop === 'x') refState.x = parseInt(val); if (prop === 'y') refState.y = parseInt(val); updateRefVisuals(); }
        function toggleRef() { refState.visible = !refState.visible; document.getElementById('refContainer').style.display = refState.visible ? 'block' : 'none'; }
        function saveState() { if (historyStack.length > 30) historyStack.shift(); historyStack.push({ pixels: ctx.getImageData(0, 0, 256, 192), attrs: [...attrData] }); }
        function undo() { if (historyStack.length <= 1) return; historyStack.pop(); const prev = historyStack[historyStack.length - 1]; ctx.putImageData(prev.pixels, 0, 0); attrData = [...prev.attrs]; redrawAttributes(); }
        function clearAll() { ctx.clearRect(0, 0, 256, 192); attrCtx.clearRect(0, 0, 256, 192); attrData.fill(56); saveState(); }

        init();
    </script>
</body>
</html>
